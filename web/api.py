#!/usr/bin/env python3.3
# -*- coding: utf-8 -*-
#
# Simple web interface to cve-search to display the last entries
# and view a specific CVE.
#
# Software is free software released under the "Modified BSD license"
#

# Copyright (c) 2013-2014 	Alexandre Dulaunoy - a@foo.be
# Copyright (c) 2014-2015 	Pieter-Jan Moreels - pieterjan.moreels@gmail.com

# imports
import os
import sys
_runPath = os.path.dirname(os.path.realpath(__file__))
sys.path.append(os.path.join(_runPath, ".."))

from tornado.wsgi import WSGIContainer
from tornado.httpserver import HTTPServer
from tornado.ioloop import IOLoop
from flask import Flask, jsonify
import subprocess, shlex
from apscheduler.schedulers.background import BackgroundScheduler


import json
import re
import random
import time
import urllib
import signal
import logging

from logging.handlers import RotatingFileHandler

from lib.Config import Configuration
import lib.CVEs as cves

# app init
app = Flask(__name__, static_folder='static', static_url_path='/static')
app.config['MONGO_DBNAME'] = Configuration.getMongoDB()
app.config['SECRET_KEY'] = str(random.getrandbits(256))

# db connectors
db = Configuration.getMongoConnection()
redisdb = Configuration.getRedisVendorConnection()

def adminStats():
    cveU = db.info.find_one({'db': 'cve'})
    cpeU = db.info.find_one({'db': 'cpe'})
    cpeOtherU = db.info.find_one({'db': 'cpeother'})
    capecU = db.info.find_one({'db': 'capec'})
    d2secU = db.info.find_one({'db': 'd2sec'})
    vendorU = db.info.find_one({'db': 'vendor'})
    vfeedU = db.info.find_one({'db': 'vfeed'})
    stats = {'cveA': db.cves.count(), 'cveU': cveU['last-modified'] if cveU is not None else None,
             'cpeA': db.cpe.count(), 'cpeU': cpeU['last-modified'] if cpeU is not None else None,
             'cpeOtherA': db.cpeother.count(), 'cpeOtherU': cpeOtherU['last-modified'] if cpeOtherU is not None else None,
             'capecA': db.capec.count(), 'capecU': capecU['last-modified'] if capecU is not None else None,
             'd2secA': db.d2sec.count(), 'd2secU': d2secU['last-modified'] if d2secU is not None else None,
             'vendorA': db.vendor.count(), 'vendorU': vendorU['last-modified'] if vendorU is not None else None,
             'vfeedA': db.vfeed.count(), 'vfeedU': vfeedU['last-modified'] if vfeedU is not None else None,
             'blA': db.mgmt_blacklist.count(), 'wlA': db.mgmt_whitelist.count(),
             'dbName': Configuration.getMongoDB(), 'dbSize': db.command("dbstats")['dataSize'],
             'dbOnDisk': db.command("dbstats")['storageSize']}
    return stats

@app.route('/api/stats', methods=['GET'])
def apistats():
  return jsonify(adminStats())

@app.route('/api/search/<product>', methods=['GET'])
def apisearch(product=None):
    if product is None:
        return (jsonify({}))
    collection = db.cves
    search = product
    cves = collection.find({"vulnerable_configuration": {'$regex': search}}).sort("Modified", -1)
    r = []
    for cve in cves:
      cve.pop('_id')
      r.append(cve)
    return jsonify({"results": r})

    # We'll see if it works later on.
    #try:
    #  cves = db.command("text", "cves", search=product)['results']
    #except:
    #  return jsonify({"error": "no text search available"})

    #cve = [x['obj'] for x in cves]
    #return jsonify(cve) 

# signal handlers
def sig_handler(sig, frame):
    print('Caught signal: %s' % sig)
    IOLoop.instance().add_callback(shutdown)

def shutdown():
    MAX_WAIT_SECONDS_BEFORE_SHUTDOWN = 3
    print('Stopping http server')
    http_server.stop()

    print('Will shutdown in %s seconds ...' % MAX_WAIT_SECONDS_BEFORE_SHUTDOWN)
    io_loop = IOLoop.instance()
    deadline = time.time() + MAX_WAIT_SECONDS_BEFORE_SHUTDOWN

    def stop_loop():
        now = time.time()
        if now < deadline and (io_loop._callbacks or io_loop._timeouts):
            io_loop.add_timeout(now + 1, stop_loop)
        else:
            io_loop.stop()
            print('Shutdown')
    stop_loop()

def _run_update():
  p = subprocess.Popen(shlex.split("python3 ../test/scheduled.py"), shell=False,
                       stdout=subprocess.PIPE, stderr=subprocess.PIPE)

  stdout, stderr = p.communicate()
  print(stdout)


if __name__ == '__main__':
    # get properties
    flaskHost = Configuration.getFlaskHost()
    flaskPort = Configuration.getFlaskPort()
    flaskDebug = Configuration.getFlaskDebug()
    # logging
    if Configuration.getLogging():
        logfile = Configuration.getLogfile()
        pathToLog = os.path.join(_runPath, logfile.rsplit('/', 1)[0])
        #pathToLog = os.path.join(_runPath, pathToLog)
        logfile = os.path.join(_runPath, logfile)
        if not os.path.exists(pathToLog):
            os.makedirs(pathToLog)
        maxLogSize = Configuration.getMaxLogSize()
        backlog = Configuration.getBacklog()
        file_handler = RotatingFileHandler(logfile, maxBytes=maxLogSize, backupCount=backlog)
        file_handler.setLevel(logging.ERROR)
        formatter = logging.Formatter("%(asctime)s - %(name)s - %(levelname)s - %(message)s")
        file_handler.setFormatter(formatter)
        app.logger.addHandler(file_handler)

    scheduler = BackgroundScheduler()
    scheduler.add_job(_run_update, 'interval', seconds=10)
    scheduler.start()
      
    if flaskDebug:
        # start debug flask server
        app.run(host=flaskHost, port=flaskPort, debug=flaskDebug)
    else:
        # start asynchronous server using tornado wrapper for flask
        # ssl connection
        print("Server starting...")
        if Configuration.useSSL():
            cert = os.path.join(_runPath, "../", Configuration.getSSLCert())
            key = os.path.join(_runPath, "../", Configuration.getSSLKey())
            ssl_options = {"certfile": cert,
                           "keyfile": key}
        else:
            ssl_options = None
        signal.signal(signal.SIGTERM, sig_handler)
        signal.signal(signal.SIGINT, sig_handler)
        global http_server
        http_server = HTTPServer(WSGIContainer(app), ssl_options=ssl_options)
        http_server.bind(flaskPort, address=flaskHost)
        http_server.start(0)  # Forks multiple sub-processes
        IOLoop.instance().start()


